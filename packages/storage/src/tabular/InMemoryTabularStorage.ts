/**
 * @license
 * Copyright 2025 Steven Roussey <sroussey@gmail.com>
 * SPDX-License-Identifier: Apache-2.0
 */

import {
  createServiceToken,
  DataPortSchemaObject,
  FromSchema,
  makeFingerprint,
  TypedArraySchemaOptions,
  uuid4,
} from "@workglow/util";
import { BaseTabularStorage, ClientProvidedKeysOption, KeyGenerationStrategy } from "./BaseTabularStorage";
import {
  AnyTabularStorage,
  AutoGeneratedKeys,
  DeleteSearchCriteria,
  InsertEntity,
  isSearchCondition,
  SimplifyPrimaryKey,
  TabularChangePayload,
  TabularSubscribeOptions,
} from "./ITabularStorage";

export const MEMORY_TABULAR_REPOSITORY = createServiceToken<AnyTabularStorage>(
  "storage.tabularRepository.inMemory"
);

/**
 * A generic in-memory key-value repository implementation.
 * Provides a simple, non-persistent storage solution suitable for testing and caching scenarios.
 *
 * @template Schema - The schema definition for the entity using JSON Schema
 * @template PrimaryKeyNames - Array of property names that form the primary key
 */
export class InMemoryTabularStorage<
  Schema extends DataPortSchemaObject,
  PrimaryKeyNames extends ReadonlyArray<keyof Schema["properties"]>,
  // computed types
  Entity = FromSchema<Schema, TypedArraySchemaOptions>,
  PrimaryKey = SimplifyPrimaryKey<Entity, PrimaryKeyNames>,
  Value = Omit<Entity, PrimaryKeyNames[number] & keyof Entity>,
  InsertType extends InsertEntity<Entity, AutoGeneratedKeys<Schema>> = InsertEntity<
    Entity,
    AutoGeneratedKeys<Schema>
  >,
> extends BaseTabularStorage<Schema, PrimaryKeyNames, Entity, PrimaryKey, Value, InsertType> {
  /** Internal storage using a Map with fingerprint strings as keys */
  values = new Map<string, Entity>();
  /** Counter for auto-incrementing integer keys */
  private autoIncrementCounter = 0;

  /**
   * Creates a new InMemoryTabularStorage instance
   * @param schema - Schema defining the structure of the entity
   * @param primaryKeyNames - Array of property names that form the primary key
   * @param indexes - Array of columns or column arrays to make searchable. Each string or single column creates a single-column index,
   *                    while each array creates a compound index with columns in the specified order.
   * @param clientProvidedKeys - How to handle client-provided values for auto-generated keys
   */
  constructor(
    schema: Schema,
    primaryKeyNames: PrimaryKeyNames,
    indexes: readonly (keyof Entity | readonly (keyof Entity)[])[] = [],
    clientProvidedKeys: ClientProvidedKeysOption = "if-missing"
  ) {
    super(schema, primaryKeyNames, indexes, clientProvidedKeys);
  }

  /**
   * Sets up the database for the repository (no-op for in-memory)
   */
  async setupDatabase(): Promise<void> {
    // No setup needed for in-memory storage
  }

  /**
   * Generates a key value for auto-generated keys
   * @param columnName - Name of the column to generate a key for
   * @param strategy - The generation strategy to use
   * @returns The generated key value
   */
  protected generateKeyValue(columnName: string, strategy: KeyGenerationStrategy): string | number {
    if (strategy === "autoincrement") {
      return ++this.autoIncrementCounter;
    } else {
      return uuid4();
    }
  }

  /**
   * Stores a key-value pair in the repository
   * @param value - The combined object to store (may be missing auto-generated keys)
   * @returns The stored entity with all keys filled in
   * @emits 'put' event with the stored entity when successful
   */
  async put(value: InsertType): Promise<Entity> {
    let entityToStore = value as unknown as Entity;

    // Handle auto-generated keys
    if (this.hasAutoGeneratedKey() && this.autoGeneratedKeyName) {
      const keyName = this.autoGeneratedKeyName as string;
      const clientProvidedValue = (value as any)[keyName];
      const hasClientValue = clientProvidedValue !== undefined && clientProvidedValue !== null;

      let shouldGenerate = false;
      if (this.clientProvidedKeys === "never") {
        // Always generate, ignore client value
        shouldGenerate = true;
      } else if (this.clientProvidedKeys === "always") {
        // Always use client value, error if missing
        if (!hasClientValue) {
          throw new Error(
            `Auto-generated key "${keyName}" is required when clientProvidedKeys is "always"`
          );
        }
        shouldGenerate = false;
      } else {
        // "if-missing" - generate only if client didn't provide
        shouldGenerate = !hasClientValue;
      }

      if (shouldGenerate) {
        const generatedValue = this.generateKeyValue(keyName, this.autoGeneratedKeyStrategy!);
        entityToStore = { ...value, [keyName]: generatedValue } as Entity;
      }
    }

    const { key } = this.separateKeyValueFromCombined(entityToStore);
    const id = await makeFingerprint(key);
    this.values.set(id, entityToStore);
    this.events.emit("put", entityToStore);
    return entityToStore;
  }

  /**
   * Stores multiple key-value pairs in the repository in a bulk operation
   * @param values - Array of combined objects to store (may be missing auto-generated keys)
   * @returns Array of stored entities with all keys filled in
   * @emits 'put' event for each value stored
   */
  async putBulk(values: InsertType[]): Promise<Entity[]> {
    return await Promise.all(values.map(async (value) => this.put(value)));
  }

  /**
   * Retrieves a value by its key
   * @param key - The primary key object to look up
   * @returns The value object if found, undefined otherwise
   * @emits 'get' event with the fingerprint ID and value when found
   */
  async get(key: PrimaryKey): Promise<Entity | undefined> {
    const id = await makeFingerprint(key);
    const out = this.values.get(id);
    this.events.emit("get", key, out);
    return out;
  }

  /**
   * Searches for entries matching a partial key
   * @param key - Partial key object to search for
   * @returns Array of matching combined objects
   * @throws Error if search criteria outside of searchable fields
   */
  async search(key: Partial<Entity>): Promise<Entity[] | undefined> {
    const searchKeys = Object.keys(key) as Array<keyof Entity>;
    if (searchKeys.length === 0) {
      return undefined;
    }

    // Find the best matching index
    const bestIndex = this.findBestMatchingIndex(searchKeys);
    if (!bestIndex) {
      throw new Error(
        `No suitable index found for the search criteria, searching for ['${searchKeys.join(
          "', '"
        )}'] with pk ['${this.primaryKeyNames.join("', '")}'] and indexes ['${this.indexes.join(
          "', '"
        )}']`
      );
    }

    // Filter results based on the search criteria
    const results = Array.from(this.values.values()).filter((item) =>
      // @ts-ignore
      Object.entries(key).every(([k, v]) => item[k] === v)
    );

    if (results.length > 0) {
      this.events.emit("search", key, results);
      return results;
    } else {
      this.events.emit("search", key, undefined);
      return undefined;
    }
  }

  /**
   * Deletes an entry by its key
   * @param key - The primary key object of the entry to delete
   * @emits 'delete' event with the fingerprint ID when successful
   */
  async delete(value: PrimaryKey | Entity): Promise<void> {
    const { key } = this.separateKeyValueFromCombined(value as Entity);
    const id = await makeFingerprint(key);
    this.values.delete(id);
    this.events.emit("delete", key as keyof Entity);
  }

  /**
   * Removes all entries from the repository
   * @emits 'clearall' event when successful
   */
  async deleteAll(): Promise<void> {
    this.values.clear();
    this.events.emit("clearall");
  }

  /**
   * Returns an array of all entries in the repository
   * @returns Array of all entries in the repository
   */
  async getAll(): Promise<Entity[] | undefined> {
    const all = Array.from(this.values.values());
    return all.length > 0 ? all : undefined;
  }

  /**
   * Returns the number of entries in the repository
   * @returns The total count of stored entries
   */
  async size(): Promise<number> {
    return this.values.size;
  }

  /**
   * Fetches a page of records from the repository.
   * @param offset - Number of records to skip
   * @param limit - Maximum number of records to return
   * @returns Array of entities or undefined if no records found
   */
  async getBulk(offset: number, limit: number): Promise<Entity[] | undefined> {
    const all = Array.from(this.values.values());
    const page = all.slice(offset, offset + limit);
    return page.length > 0 ? page : undefined;
  }

  /**
   * Deletes all entries matching the specified search criteria.
   * Supports multiple columns with optional comparison operators.
   *
   * @param criteria - Object with column names as keys and values or SearchConditions
   */
  async deleteSearch(criteria: DeleteSearchCriteria<Entity>): Promise<void> {
    const criteriaKeys = Object.keys(criteria) as Array<keyof Entity>;
    if (criteriaKeys.length === 0) {
      return;
    }

    // Convert to array first to avoid iterator issues when modifying the Map
    const entries = Array.from(this.values.entries());

    const entriesToDelete = entries.filter(([_, entity]) => {
      // All criteria must match (AND logic)
      for (const column of criteriaKeys) {
        const criterion = criteria[column];
        const columnValue = entity[column];

        if (isSearchCondition(criterion)) {
          const { value, operator } = criterion;
          // Cast to any for comparison - TypeScript can't infer the type relationship
          const v = value as any;
          const cv = columnValue as any;
          switch (operator) {
            case "=":
              if (cv !== v) return false;
              break;
            case "<":
              if (cv === null || cv === undefined || !(cv < v)) return false;
              break;
            case "<=":
              if (cv === null || cv === undefined || !(cv <= v)) return false;
              break;
            case ">":
              if (cv === null || cv === undefined || !(cv > v)) return false;
              break;
            case ">=":
              if (cv === null || cv === undefined || !(cv >= v)) return false;
              break;
            default:
              return false;
          }
        } else {
          // Direct value means equality
          if (columnValue !== criterion) return false;
        }
      }
      return true;
    });

    // Delete the filtered entries and emit events for each
    for (const [id, entity] of entriesToDelete) {
      this.values.delete(id);
      const { key } = this.separateKeyValueFromCombined(entity);
      this.events.emit("delete", key as keyof Entity);
    }
  }

  /**
   * Subscribes to changes in the repository.
   * Since InMemory is both client and server, changes are detected via local events.
   *
   * @param callback - Function called when a change occurs
   * @param options - Optional subscription options (not used for in-memory)
   * @returns Unsubscribe function
   */
  subscribeToChanges(
    callback: (change: TabularChangePayload<Entity>) => void,
    options?: TabularSubscribeOptions
  ): () => void {
    const handlePut = (entity: Entity) => {
      // InMemory can't distinguish INSERT vs UPDATE without tracking
      callback({ type: "UPDATE", new: entity });
    };

    const handleDelete = (_key: keyof Entity) => {
      callback({ type: "DELETE" });
    };

    const handleClearAll = () => {
      callback({ type: "DELETE" });
    };

    this.events.on("put", handlePut);
    this.events.on("delete", handleDelete);
    this.events.on("clearall", handleClearAll);

    return () => {
      this.events.off("put", handlePut);
      this.events.off("delete", handleDelete);
      this.events.off("clearall", handleClearAll);
    };
  }

  /**
   * Destroys the repository and frees up resources.
   */
  destroy(): void {
    this.values.clear();
  }
}
