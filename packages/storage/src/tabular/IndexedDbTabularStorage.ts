/**
 * @license
 * Copyright 2025 Steven Roussey <sroussey@gmail.com>
 * SPDX-License-Identifier: Apache-2.0
 */

import {
  createServiceToken,
  DataPortSchemaObject,
  FromSchema,
  makeFingerprint,
  TypedArraySchemaOptions,
  uuid4,
} from "@workglow/util";
import { HybridSubscriptionManager } from "../util/HybridSubscriptionManager";
import {
  ensureIndexedDbTable,
  ExpectedIndexDefinition,
  MigrationOptions,
} from "../util/IndexedDbTable";
import { BaseTabularStorage, ClientProvidedKeysOption, KeyGenerationStrategy } from "./BaseTabularStorage";
import {
  AnyTabularStorage,
  AutoGeneratedKeys,
  DeleteSearchCriteria,
  InsertEntity,
  isSearchCondition,
  SearchOperator,
  SimplifyPrimaryKey,
  TabularChangePayload,
  TabularSubscribeOptions,
} from "./ITabularStorage";

export const IDB_TABULAR_REPOSITORY = createServiceToken<AnyTabularStorage>(
  "storage.tabularRepository.indexedDb"
);

/**
 * A tabular repository implementation using IndexedDB for browser-based storage.
 *
 * @template Schema - The schema definition for the entity
 * @template PrimaryKeyNames - Array of property names that form the primary key
 */
export class IndexedDbTabularStorage<
  Schema extends DataPortSchemaObject,
  PrimaryKeyNames extends ReadonlyArray<keyof Schema["properties"]>,
  // computed types
  Entity = FromSchema<Schema, TypedArraySchemaOptions>,
  PrimaryKey = SimplifyPrimaryKey<Entity, PrimaryKeyNames>,
  Value = Omit<Entity, PrimaryKeyNames[number] & keyof Entity>,
  InsertType extends InsertEntity<Entity, AutoGeneratedKeys<Schema>> = InsertEntity<
    Entity,
    AutoGeneratedKeys<Schema>
  >,
> extends BaseTabularStorage<Schema, PrimaryKeyNames, Entity, PrimaryKey, Value, InsertType> {
  /** Promise that resolves to the IndexedDB database instance */
  private db: IDBDatabase | undefined;
  /** Promise to track ongoing database setup to prevent concurrent setup calls */
  private setupPromise: Promise<IDBDatabase> | null = null;
  /** Migration options for database schema changes */
  private migrationOptions: MigrationOptions;
  /** Shared hybrid subscription manager */
  private hybridManager: HybridSubscriptionManager<
    Entity,
    string,
    TabularChangePayload<Entity>
  > | null = null;
  /** Hybrid subscription options */
  private readonly hybridOptions: {
    readonly useBroadcastChannel: boolean;
    readonly backupPollingIntervalMs: number;
  };

  /**
   * Creates a new IndexedDB-based tabular repository.
   * @param table - Name of the IndexedDB store to use.
   * @param schema - Schema defining the structure of the entity
   * @param primaryKeyNames - Array of property names that form the primary key
   * @param indexes - Array of columns or column arrays to make searchable. Each string or single column creates a single-column index,
   *                    while each array creates a compound index with columns in the specified order.
   * @param migrationOptions - Options for handling database schema migrations
   * @param clientProvidedKeys - How to handle client-provided values for auto-generated keys
   */
  constructor(
    public table: string = "tabular_store",
    schema: Schema,
    primaryKeyNames: PrimaryKeyNames,
    indexes: readonly (keyof Entity | readonly (keyof Entity)[])[] = [],
    migrationOptions: MigrationOptions & {
      readonly useBroadcastChannel?: boolean;
      readonly backupPollingIntervalMs?: number;
    } = {},
    clientProvidedKeys: ClientProvidedKeysOption = "if-missing"
  ) {
    super(schema, primaryKeyNames, indexes, clientProvidedKeys);
    this.migrationOptions = migrationOptions;
    this.hybridOptions = {
      useBroadcastChannel: migrationOptions.useBroadcastChannel ?? true,
      backupPollingIntervalMs: migrationOptions.backupPollingIntervalMs ?? 5000,
    };
  }

  /**
   * Internal method to get the database, setting it up if needed.
   * This ensures lazy initialization of the database.
   */
  private async getDb(): Promise<IDBDatabase> {
    if (this.db) return this.db;
    await this.setupDatabase();
    return this.db!;
  }

  /**
   * Sets up the IndexedDB database table with the required schema and indexes.
   * Must be called before using any other methods.
   */
  public async setupDatabase(): Promise<void> {
    if (this.db) return;
    if (this.setupPromise) {
      await this.setupPromise;
      return;
    }

    this.setupPromise = this.performSetup();
    try {
      this.db = await this.setupPromise;
    } finally {
      this.setupPromise = null;
    }
  }

  /**
   * Internal method to perform the actual database setup
   */
  private async performSetup(): Promise<IDBDatabase> {
    const pkColumns = super.primaryKeyColumns() as string[];

    // Create index definitions for both single and compound indexes
    const expectedIndexes: ExpectedIndexDefinition[] = [];

    for (const spec of this.indexes) {
      // Handle compound index
      const columns = spec as Array<keyof Entity>;
      // Skip if this is just the primary key or a prefix of it
      if (columns.length <= pkColumns.length) {
        const isPkPrefix = columns.every((col, idx) => col === pkColumns[idx]);
        if (isPkPrefix) continue;
      }

      // Create compound index name and keyPath
      const columnNames = columns.map((col) => String(col));
      const indexName = columnNames.join("_");
      expectedIndexes.push({
        name: indexName,
        keyPath: columnNames.length === 1 ? columnNames[0] : columnNames,
        options: { unique: false },
      });
    }

    const primaryKey = pkColumns.length === 1 ? pkColumns[0] : pkColumns;

    // Determine if we should use autoIncrement
    // IndexedDB autoIncrement only works with single numeric keys
    const useAutoIncrement =
      this.hasAutoGeneratedKey() &&
      this.autoGeneratedKeyStrategy === "autoincrement" &&
      pkColumns.length === 1;

    // Ensure that our table is created/upgraded only if the structure (indexes) has changed.
    return await ensureIndexedDbTable(
      this.table,
      primaryKey,
      expectedIndexes,
      this.migrationOptions,
      useAutoIncrement
    );
  }

  /**
   * Generates a key value for UUID keys
   * Integer autoincrement keys are handled by IndexedDB's autoIncrement
   * @param columnName - Name of the column to generate a key for
   * @param strategy - The generation strategy to use
   * @returns The generated key value
   */
  protected generateKeyValue(columnName: string, strategy: KeyGenerationStrategy): string | number {
    if (strategy === "uuid") {
      return uuid4();
    }
    // autoincrement is handled by IndexedDB's autoIncrement option
    throw new Error(
      `IndexedDB autoincrement keys are generated by the database, not client-side. Column: ${columnName}`
    );
  }

  /**
   * Stores a row in the repository.
   * @param record - The entity to store (may be missing auto-generated keys).
   * @returns The stored entity
   * @emits put - Emitted when the value is successfully stored
   */
  async put(record: InsertType): Promise<Entity> {
    const db = await this.getDb();
    let recordToStore = record as unknown as Entity;

    // Handle auto-generated keys
    if (this.hasAutoGeneratedKey() && this.autoGeneratedKeyName) {
      const keyName = String(this.autoGeneratedKeyName);
      const clientProvidedValue = (record as any)[keyName];
      const hasClientValue = clientProvidedValue !== undefined && clientProvidedValue !== null;

      if (this.autoGeneratedKeyStrategy === "uuid") {
        // UUID generation - must be done client-side
        let shouldGenerate = false;
        if (this.clientProvidedKeys === "never") {
          shouldGenerate = true;
        } else if (this.clientProvidedKeys === "always") {
          if (!hasClientValue) {
            throw new Error(
              `Auto-generated key "${keyName}" is required when clientProvidedKeys is "always"`
            );
          }
          shouldGenerate = false;
        } else {
          // "if-missing"
          shouldGenerate = !hasClientValue;
        }

        if (shouldGenerate) {
          const generatedValue = this.generateKeyValue(keyName, "uuid");
          recordToStore = { ...record, [keyName]: generatedValue } as Entity;
        }
      } else if (this.autoGeneratedKeyStrategy === "autoincrement") {
        // Autoincrement handled by IndexedDB
        // If clientProvidedKeys is "always", require the value
        if (this.clientProvidedKeys === "always" && !hasClientValue) {
          throw new Error(
            `Auto-generated key "${keyName}" is required when clientProvidedKeys is "always"`
          );
        }
        // If clientProvidedKeys is "never", omit the key to let IDB generate
        if (this.clientProvidedKeys === "never") {
          const { [keyName]: _, ...rest } = record as Record<string, unknown>;
          recordToStore = rest as Entity;
        }
        // "if-missing": use client value if provided, omit if not
      }
    }

    // Merge key and value, ensuring all fields are at the root level for indexing
    return new Promise((resolve, reject) => {
      const transaction = db.transaction(this.table, "readwrite");
      const store = transaction.objectStore(this.table);
      const request = store.put(recordToStore);
      request.onerror = () => {
        reject(request.error);
      };
      request.onsuccess = () => {
        // For autoincrement keys, we need to update the record with the generated key
        if (
          this.hasAutoGeneratedKey() &&
          this.autoGeneratedKeyName &&
          this.autoGeneratedKeyStrategy === "autoincrement"
        ) {
          const keyName = String(this.autoGeneratedKeyName);
          if (recordToStore[keyName as keyof Entity] === undefined) {
            // Get the generated key from the request result
            recordToStore = { ...recordToStore, [keyName]: request.result } as Entity;
          }
        }
        this.events.emit("put", recordToStore);
        resolve(recordToStore);
      };
      transaction.oncomplete = () => {
        // Notify hybrid manager of local change
        this.hybridManager?.notifyLocalChange();
      };
    });
  }

  /**
   * Stores multiple rows in the repository in a bulk operation.
   * @param records - Array of entities to store (may be missing auto-generated keys).
   * @returns Array of stored entities
   * @emits put - Emitted for each record successfully stored
   */
  async putBulk(records: InsertType[]): Promise<Entity[]> {
    // Use individual put calls to ensure auto-generated keys are handled correctly
    return await Promise.all(records.map((record) => this.put(record)));
  }

  protected getPrimaryKeyAsOrderedArray(key: PrimaryKey) {
    return super
      .getPrimaryKeyAsOrderedArray(key)
      .map((value) => (typeof value === "bigint" ? value.toString() : value));
  }

  private getIndexedKey(key: PrimaryKey): any {
    const keys = super
      .getPrimaryKeyAsOrderedArray(key)
      .map((value) => (typeof value === "bigint" ? value.toString() : value));
    return keys.length === 1 ? keys[0] : keys;
  }

  /**
   * Retrieves a value from the repository by its key.
   * @param key - The key object.
   * @returns The value object or undefined if not found.
   * @emits get - Emitted when the value is successfully retrieved
   */
  async get(key: PrimaryKey): Promise<Entity | undefined> {
    const db = await this.getDb();
    return new Promise((resolve, reject) => {
      const transaction = db.transaction(this.table, "readonly");
      const store = transaction.objectStore(this.table);
      const request = store.get(this.getIndexedKey(key));
      request.onerror = () => reject(request.error);
      request.onsuccess = () => {
        if (!request.result) {
          this.events.emit("get", key, undefined);
          resolve(undefined);
          return;
        }
        this.events.emit("get", key, request.result);
        resolve(request.result);
      };
    });
  }

  /**
   * Returns an array of all entries in the repository.
   * @returns Array of all entries in the repository.
   */
  async getAll(): Promise<Entity[] | undefined> {
    const db = await this.getDb();
    const transaction = db.transaction(this.table, "readonly");
    const store = transaction.objectStore(this.table);
    const request = store.getAll();
    return new Promise((resolve, reject) => {
      request.onerror = () => reject(request.error);
      request.onsuccess = () => {
        const values = request.result;
        resolve(values.length > 0 ? values : undefined);
      };
    });
  }

  /**
   * Searches for records matching the specified partial query.
   * It uses an appropriate index if one exists, or scans all records.
   * @param key - Partial query object.
   * @returns Array of matching records or undefined.
   */
  async search(key: Partial<Entity>): Promise<Entity[] | undefined> {
    const db = await this.getDb();
    const searchKeys = Object.keys(key) as Array<keyof Entity>;
    if (searchKeys.length === 0) {
      return undefined;
    }

    // Find the best matching index for the search
    const bestIndex = this.findBestMatchingIndex(searchKeys);
    if (!bestIndex) {
      throw new Error("No suitable index found for the search criteria");
    }

    return new Promise((resolve, reject) => {
      const transaction = db.transaction(this.table, "readonly");
      const store = transaction.objectStore(this.table);

      // For compound indexes, the index name is the columns joined by underscore
      const indexName = bestIndex.join("_");
      const primaryKeyName = this.primaryKeyColumns().join("_");
      const isPrimaryKey = indexName === primaryKeyName;

      // Get the values for the index columns that we have
      const indexValues: IDBValidKey[] = [];

      // Collect values for consecutive columns from the start of the index
      for (const col of bestIndex) {
        const val = key[col];
        // Break on first undefined value for compound index
        if (val === undefined) break;
        if (typeof val !== "string" && typeof val !== "number") {
          throw new Error(`Invalid value type for indexed column ${String(col)}`);
        }
        indexValues.push(val);
      }

      // If we have at least one valid index value, use it
      if (indexValues.length > 0) {
        const index = isPrimaryKey ? store : store.index(indexName);
        const isPartialMatch = indexValues.length < bestIndex.length;

        if (isPartialMatch) {
          // For partial matches on compound indexes, we need to handle two cases:
          // 1. If all columns in the compound index are required in the schema,
          //    we can use cursor-based prefix matching (efficient)
          // 2. If any columns are optional (could be undefined), records without those
          //    values won't be in the index, so we must do a full scan

          // Check if all columns in the compound index are required
          const allColumnsRequired = bestIndex.every((col) => {
            const colName = String(col);
            return this.schema.required?.includes(colName);
          });

          if (allColumnsRequired) {
            // All index columns are required, so all records will be in the index
            // We can use cursor-based prefix matching for better performance
            const results: Entity[] = [];
            const keyRange = IDBKeyRange.lowerBound(indexValues);
            const cursorRequest = index.openCursor(keyRange);

            cursorRequest.onsuccess = () => {
              const cursor = cursorRequest.result;
              if (cursor) {
                const item = cursor.value as Entity;
                const cursorKey = Array.isArray(cursor.key) ? cursor.key : [cursor.key];

                // Check if cursor key still matches our prefix
                const prefixMatches = indexValues.every((val, idx) => cursorKey[idx] === val);

                if (!prefixMatches) {
                  // Moved past our prefix range
                  resolve(results.length > 0 ? results : undefined);
                  return;
                }

                // Check all search criteria (including non-indexed columns)
                // @ts-ignore
                const matches = Object.entries(key).every(([k, v]) => item[k] === v);
                if (matches) {
                  results.push(item);
                }
                cursor.continue();
              } else {
                // Cursor exhausted
                resolve(results.length > 0 ? results : undefined);
              }
            };

            cursorRequest.onerror = () => {
              reject(cursorRequest.error);
            };
          } else {
            // Some index columns are optional, records with undefined values won't be indexed
            // Fall back to full scan to ensure we don't miss any matching records
            const getAllRequest = store.getAll();

            getAllRequest.onsuccess = () => {
              const allRecords: Entity[] = getAllRequest.result;
              const results = allRecords.filter((item) =>
                // @ts-ignore
                Object.entries(key).every(([k, v]) => item[k] === v)
              );
              resolve(results.length > 0 ? results : undefined);
            };

            getAllRequest.onerror = () => {
              reject(getAllRequest.error);
            };
          }
        } else {
          // Exact match: use getAll with the exact key
          const request = index.getAll(indexValues.length === 1 ? indexValues[0] : indexValues);

          request.onsuccess = () => {
            // Filter results for any additional search keys
            const results = request.result.filter((item: Entity) =>
              // @ts-ignore
              Object.entries(key).every(([k, v]) => item[k] === v)
            );
            resolve(results.length > 0 ? results : undefined);
          };

          request.onerror = () => {
            console.error("Search error:", request.error);
            reject(request.error);
          };
        }
      } else {
        throw new Error(`No valid values provided for indexed columns: ${bestIndex.join(", ")}`);
      }
    });
  }

  /**
   * Deletes a row from the repository.
   * @param key - The key object to delete.
   */
  async delete(key: PrimaryKey): Promise<void> {
    const db = await this.getDb();
    return new Promise((resolve, reject) => {
      const transaction = db.transaction(this.table, "readwrite");
      const store = transaction.objectStore(this.table);
      const request = store.delete(this.getIndexedKey(key));
      request.onerror = () => reject(request.error);
      request.onsuccess = () => {
        this.events.emit("delete", key as keyof Entity);
        resolve();
      };
      transaction.oncomplete = () => {
        // Notify hybrid manager of local change
        this.hybridManager?.notifyLocalChange();
      };
    });
  }

  /**
   * Deletes all records from the repository.
   * @emits clearall - Emitted when all values are deleted
   */
  async deleteAll(): Promise<void> {
    const db = await this.getDb();
    return new Promise((resolve, reject) => {
      const transaction = db.transaction(this.table, "readwrite");
      const store = transaction.objectStore(this.table);
      const request = store.clear();
      request.onerror = () => reject(request.error);
      request.onsuccess = () => {
        this.events.emit("clearall");
        resolve();
      };
      transaction.oncomplete = () => {
        // Notify hybrid manager of local change
        this.hybridManager?.notifyLocalChange();
      };
    });
  }

  /**
   * Returns the total number of rows in the repository.
   * @returns Count of stored items.
   */
  async size(): Promise<number> {
    const db = await this.getDb();
    return new Promise((resolve, reject) => {
      const transaction = db.transaction(this.table, "readonly");
      const store = transaction.objectStore(this.table);
      const request = store.count();
      request.onerror = () => reject(request.error);
      request.onsuccess = () => resolve(request.result);
    });
  }

  /**
   * Fetches a page of records from the repository.
   * @param offset - Number of records to skip
   * @param limit - Maximum number of records to return
   * @returns Array of entities or undefined if no records found
   */
  async getBulk(offset: number, limit: number): Promise<Entity[] | undefined> {
    const db = await this.getDb();
    return new Promise((resolve, reject) => {
      const transaction = db.transaction(this.table, "readonly");
      const store = transaction.objectStore(this.table);
      const request = store.openCursor();
      const entities: Entity[] = [];
      let currentIndex = 0;

      request.onerror = () => reject(request.error);
      request.onsuccess = () => {
        const cursor = request.result;
        if (cursor) {
          // Skip records until we reach the offset
          if (currentIndex < offset) {
            currentIndex++;
            cursor.continue();
            return;
          }
          
          // Collect records up to the limit
          if (entities.length < limit) {
            entities.push(cursor.value);
            currentIndex++;
            cursor.continue();
          } else {
            // We've collected enough records
            resolve(entities.length > 0 ? entities : undefined);
          }
        } else {
          // No more records
          resolve(entities.length > 0 ? entities : undefined);
        }
      };
    });
  }

  /**
   * Checks if a record matches all criteria conditions.
   * @param record - The record to check
   * @param criteria - The search criteria
   * @returns true if all conditions match
   */
  private matchesCriteria(record: Entity, criteria: DeleteSearchCriteria<Entity>): boolean {
    for (const column of Object.keys(criteria) as Array<keyof Entity>) {
      const criterion = criteria[column];
      const recordValue = record[column];

      let operator: SearchOperator = "=";
      let value: Entity[keyof Entity];

      if (isSearchCondition(criterion)) {
        operator = criterion.operator;
        value = criterion.value as Entity[keyof Entity];
      } else {
        value = criterion as Entity[keyof Entity];
      }

      // Skip null values for comparison operators
      if (operator !== "=" && (recordValue === null || recordValue === undefined)) {
        return false;
      }

      switch (operator) {
        case "=":
          if (recordValue !== value) return false;
          break;
        case "<":
          if (!(recordValue < value)) return false;
          break;
        case "<=":
          if (!(recordValue <= value)) return false;
          break;
        case ">":
          if (!(recordValue > value)) return false;
          break;
        case ">=":
          if (!(recordValue >= value)) return false;
          break;
        default:
          return false;
      }
    }
    return true;
  }

  /**
   * Deletes all entries matching the specified search criteria.
   * Supports multiple columns with optional comparison operators.
   *
   * @param criteria - Object with column names as keys and values or SearchConditions
   */
  async deleteSearch(criteria: DeleteSearchCriteria<Entity>): Promise<void> {
    const criteriaKeys = Object.keys(criteria) as Array<keyof Entity>;
    if (criteriaKeys.length === 0) {
      return;
    }

    const db = await this.getDb();

    return new Promise(async (resolve, reject) => {
      try {
        const transaction = db.transaction(this.table, "readwrite");
        const store = transaction.objectStore(this.table);

        // Set up transaction event handlers
        transaction.oncomplete = () => {
          this.events.emit("delete", criteriaKeys[0] as keyof Entity);
          // Notify hybrid manager of local change
          this.hybridManager?.notifyLocalChange();
          resolve();
        };

        transaction.onerror = () => {
          reject(transaction.error);
        };

        // Get all records and filter
        const getAllRequest = store.getAll();

        getAllRequest.onsuccess = () => {
          const allRecords: Entity[] = getAllRequest.result;

          // Filter records that match all criteria
          const recordsToDelete = allRecords.filter((record) =>
            this.matchesCriteria(record, criteria)
          );

          if (recordsToDelete.length === 0) {
            // No records to delete
            return;
          }

          // Delete each record that matches the criteria
          for (const record of recordsToDelete) {
            // Extract the primary key from the record
            const primaryKey = this.primaryKeyColumns().reduce((key, col) => {
              // @ts-ignore - We know these properties exist on the record
              key[col] = record[col];
              return key;
            }, {} as PrimaryKey);

            // Delete the record using the primary key
            const request = store.delete(this.getIndexedKey(primaryKey));

            request.onerror = () => {
              console.error("Error deleting record:", request.error);
            };
          }
        };

        getAllRequest.onerror = () => {
          reject(getAllRequest.error);
        };
      } catch (error) {
        reject(error);
      }
    });
  }

  /**
   * Gets or creates the shared hybrid subscription manager.
   * This ensures all subscriptions share a single manager.
   */
  private getHybridManager(): HybridSubscriptionManager<
    Entity,
    string,
    TabularChangePayload<Entity>
  > {
    if (!this.hybridManager) {
      // Generate unique channel name based on table name
      const channelName = `indexeddb-tabular-${this.table}`;

      this.hybridManager = new HybridSubscriptionManager<
        Entity,
        string,
        TabularChangePayload<Entity>
      >(
        channelName,
        async () => {
          // Fetch all entities and create a map keyed by entity fingerprint
          const entities = (await this.getAll()) || [];
          const map = new Map<string, Entity>();
          for (const entity of entities) {
            const { key } = this.separateKeyValueFromCombined(entity);
            const fingerprint = await makeFingerprint(key);
            map.set(fingerprint, entity);
          }
          return map;
        },
        (a, b) => JSON.stringify(a) === JSON.stringify(b),
        {
          insert: (item) => ({ type: "INSERT" as const, new: item }),
          update: (oldItem, newItem) => ({ type: "UPDATE" as const, old: oldItem, new: newItem }),
          delete: (item) => ({ type: "DELETE" as const, old: item }),
        },
        {
          defaultIntervalMs: 1000,
          useBroadcastChannel: this.hybridOptions.useBroadcastChannel,
          backupPollingIntervalMs: this.hybridOptions.backupPollingIntervalMs,
        }
      );
    }
    return this.hybridManager;
  }

  /**
   * Subscribes to changes in the repository.
   * Uses polling since IndexedDB has no native cross-tab change notifications.
   *
   * @param callback - Function called when a change occurs
   * @param options - Optional subscription options including polling interval
   * @returns Unsubscribe function
   */
  subscribeToChanges(
    callback: (change: TabularChangePayload<Entity>) => void,
    options?: TabularSubscribeOptions
  ): () => void {
    // Note: We don't await setupDatabase() here to keep the method synchronous
    // The getAll() method in the hybrid manager will call setupDatabase() when needed
    const intervalMs = options?.pollingIntervalMs ?? 1000;
    const manager = this.getHybridManager();
    return manager.subscribe(callback, { intervalMs });
  }

  /**
   * Destroys this repository and frees up resources.
   */
  destroy(): void {
    if (this.hybridManager) {
      this.hybridManager.destroy();
      this.hybridManager = null;
    }
    this.db?.close();
  }
}
