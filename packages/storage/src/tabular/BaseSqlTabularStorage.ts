/**
 * @license
 * Copyright 2025 Steven Roussey <sroussey@gmail.com>
 * SPDX-License-Identifier: Apache-2.0
 */

import {
  DataPortSchemaObject,
  FromSchema,
  JsonSchema,
  TypedArraySchemaOptions,
} from "@workglow/util";
import { BaseTabularStorage, ClientProvidedKeysOption } from "./BaseTabularStorage";
import {
  AutoGeneratedKeys,
  InsertEntity,
  SimplifyPrimaryKey,
  ValueOptionType,
} from "./ITabularStorage";

// BaseTabularStorage is a tabular store that uses SQLite and Postgres use as common code

/**
 * Base class for SQL-based tabular repositories that implements common functionality
 * for both SQLite and PostgreSQL database implementations.
 *
 * @template Schema - The schema definition for the entity using JSON Schema
 * @template PrimaryKeyNames - Array of property names that form the primary key
 */
export abstract class BaseSqlTabularStorage<
  Schema extends DataPortSchemaObject,
  PrimaryKeyNames extends ReadonlyArray<keyof Schema["properties"]>,
  // computed types
  Entity = FromSchema<Schema, TypedArraySchemaOptions>,
  PrimaryKey = SimplifyPrimaryKey<Entity, PrimaryKeyNames>,
  Value = Omit<Entity, PrimaryKeyNames[number] & keyof Entity>,
  InsertType extends InsertEntity<Entity, AutoGeneratedKeys<Schema>> = InsertEntity<
    Entity,
    AutoGeneratedKeys<Schema>
  >,
> extends BaseTabularStorage<Schema, PrimaryKeyNames, Entity, PrimaryKey, Value, InsertType> {
  /**
   * Creates a new instance of BaseSqlTabularStorage
   * @param table - The name of the database table to use for storage
   * @param schema - Schema defining the structure of the entity
   * @param primaryKeyNames - Array of property names that form the primary key
   * @param indexes - Array of columns or column arrays to make searchable. Each string or single column creates a single-column index,
   *                    while each array creates a compound index with columns in the specified order.
   * @param clientProvidedKeys - How to handle client-provided values for auto-generated keys
   */
  constructor(
    protected readonly table: string = "tabular_store",
    schema: Schema,
    primaryKeyNames: PrimaryKeyNames,
    indexes: readonly (keyof Entity | readonly (keyof Entity)[])[] = [],
    clientProvidedKeys: ClientProvidedKeysOption = "if-missing"
  ) {
    super(schema, primaryKeyNames, indexes, clientProvidedKeys);
    this.validateTableAndSchema();
  }

  /**
   * Maps JavaScript/TypeScript types to their corresponding SQL type
   * Must be implemented by derived classes for specific SQL dialects
   */
  protected abstract mapTypeToSQL(typeDef: JsonSchema): string;

  /**
   * Generates the SQL column definitions for primary key fields
   * @returns SQL string containing primary key column definitions
   */
  protected constructPrimaryKeyColumns($delimiter: string = ""): string {
    const cols = Object.entries<JsonSchema>(this.primaryKeySchema.properties)
      .map(([key, typeDef]) => {
        const sqlType = this.mapTypeToSQL(typeDef);
        return `${$delimiter}${key}${$delimiter} ${sqlType} NOT NULL`;
      })
      .join(", ");
    return cols;
  }

  /**
   * Generates the SQL column definitions for value fields
   * @returns SQL string containing value column definitions
   */
  protected constructValueColumns($delimiter: string = ""): string {
    const requiredSet = new Set(this.valueSchema.required ?? []);
    const cols = Object.entries<JsonSchema>(this.valueSchema.properties)
      .map(([key, typeDef]) => {
        const sqlType = this.mapTypeToSQL(typeDef);
        // Check if the property is nullable based on schema definition or if it's not required
        const isRequired = requiredSet.has(key);
        const nullable = !isRequired || this.isNullable(typeDef);
        return `${$delimiter}${key}${$delimiter} ${sqlType}${nullable ? " NULL" : " NOT NULL"}`;
      })
      .join(", ");
    if (cols.length > 0) {
      return `, ${cols}`;
    } else {
      return "";
    }
  }

  /**
   * Determines if a schema type allows null values
   * @param typeDef - The schema type definition
   * @returns true if the type allows null values
   */
  protected isNullable(typeDef: JsonSchema): boolean {
    if (typeof typeDef === "boolean") return typeDef;

    // Check for direct null type
    if (typeDef.type === "null") {
      return true;
    }

    // Check for type as an array that includes null (e.g., type: ["null", "string"])
    if (Array.isArray(typeDef.type)) {
      return typeDef.type.includes("null");
    }

    // Check for union types that include null (anyOf)
    if (typeDef.anyOf && Array.isArray(typeDef.anyOf)) {
      return typeDef.anyOf.some((type: any) => type.type === "null");
    }

    // Check for union types that include null (oneOf)
    if (typeDef.oneOf && Array.isArray(typeDef.oneOf)) {
      return typeDef.oneOf.some((type: any) => type.type === "null");
    }

    return false;
  }

  /**
   * Returns a comma-separated list of primary key column names
   * @returns Formatted string of primary key column names
   */
  protected primaryKeyColumnList($delimiter: string = ""): string {
    return $delimiter + this.primaryKeyColumns().join(`${$delimiter}, ${$delimiter}`) + $delimiter;
  }

  /**
   * Returns a comma-separated list of value column names
   * @returns Formatted string of value column names
   */
  protected valueColumnList($delimiter: string = ""): string {
    return $delimiter + this.valueColumns().join(`${$delimiter}, ${$delimiter}`) + $delimiter;
  }

  /**
   * Gets the real underlying type from possibly union types
   * For example, for a union with null, this extracts the non-null type
   * @param typeDef - The schema to extract from
   * @returns The non-null type from the schema
   */
  protected getNonNullType(typeDef: JsonSchema): JsonSchema {
    if (typeof typeDef === "boolean") return typeDef;

    if (typeDef.anyOf && Array.isArray(typeDef.anyOf)) {
      const nonNullType = typeDef.anyOf.find((t: any) => t.type !== "null");
      if (nonNullType) {
        return nonNullType;
      }
    }
    if (typeDef.oneOf && Array.isArray(typeDef.oneOf)) {
      const nonNullType = typeDef.oneOf.find((t: any) => t.type !== "null");
      if (nonNullType) {
        return nonNullType;
      }
    }
    return typeDef;
  }

  /**
   * Converts a value object into an ordered array based on the valueSchema
   * This ensures consistent parameter ordering for SQL queries
   * @param value - The value object to convert
   * @returns Array of values ordered according to the schema
   * @throws Error if a required field is missing
   */
  protected getValueAsOrderedArray(value: Value): ValueOptionType[] {
    const orderedParams: ValueOptionType[] = [];
    const valueAsRecord = value as Record<string, Entity[keyof Entity]>;
    const requiredSet = new Set(this.valueSchema.required ?? []);
    for (const key in this.valueSchema.properties) {
      if (Object.prototype.hasOwnProperty.call(valueAsRecord, key)) {
        const val = valueAsRecord[key];
        // Convert undefined to null for optional fields
        if (val === undefined && !requiredSet.has(key)) {
          orderedParams.push(null);
        } else {
          orderedParams.push(this.jsToSqlValue(key, val));
        }
      } else {
        // If the field is required, throw an error
        if (requiredSet.has(key)) {
          throw new Error(`Missing required value field: ${key}`);
        }
        // If the field is optional, use null
        orderedParams.push(null);
      }
    }
    return orderedParams;
  }

  /**
   * Converts a primary key object into an ordered array based on the schema
   * This ensures consistent parameter ordering for storage operations
   * @param key - The primary key object to convert
   * @returns Array of key values ordered according to the schema
   */
  protected getPrimaryKeyAsOrderedArray(key: PrimaryKey): ValueOptionType[] {
    const orderedParams: ValueOptionType[] = [];
    const keyObj = key as Record<string, Entity[keyof Entity]>;
    for (const k of Object.keys(this.primaryKeySchema.properties)) {
      if (k in keyObj) {
        const value = keyObj[k];
        if (value === null) {
          throw new Error(`Primary key field ${k} cannot be null`);
        }
        orderedParams.push(this.jsToSqlValue(k, value));
      } else {
        throw new Error(`Missing required primary key field: ${k}`);
      }
    }
    return orderedParams;
  }

  protected jsToSqlValue(column: string, value: Entity[keyof Entity]): ValueOptionType {
    const typeDef = this.schema.properties[column];
    if (!typeDef) {
      return value as ValueOptionType;
    }

    // Handle null values for nullable columns
    if (value === null && this.isNullable(typeDef)) {
      return null;
    }

    // Extract the non-null type for proper handling
    const actualType = this.getNonNullType(typeDef);
    if (typeof actualType === "boolean") {
      return value as ValueOptionType;
    }

    if (actualType.contentEncoding === "blob") {
      const v: any = value;
      if (v instanceof Uint8Array) {
        return v as unknown as ValueOptionType;
      }
      if (typeof Buffer !== "undefined" && v instanceof Buffer) {
        return new Uint8Array(v) as unknown as ValueOptionType;
      }
      if (Array.isArray(v)) {
        return new Uint8Array(v) as unknown as ValueOptionType;
      }
      return v as unknown as ValueOptionType;
    } else if (value instanceof Date) {
      // Convert all Date objects to ISO string regardless of type definition
      return value.toISOString();
    } else {
      return value as ValueOptionType;
    }
  }

  protected sqlToJsValue(column: string, value: ValueOptionType): Entity[keyof Entity] {
    // Get the type definition
    const typeDef = this.schema.properties[column];
    if (!typeDef) {
      return value as Entity[keyof Entity];
    }

    // Handle null values
    if (value === null && this.isNullable(typeDef)) {
      return null as any;
    }

    // Extract the non-null type for proper handling
    const actualType = this.getNonNullType(typeDef);
    if (typeof actualType === "boolean") {
      return value as Entity[keyof Entity];
    }

    if (actualType.contentEncoding === "blob") {
      const v: any = value;
      if (typeof Buffer !== "undefined" && v instanceof Buffer) {
        return new Uint8Array(v) as Entity[keyof Entity];
      }
      if (v instanceof Uint8Array) {
        return v as Entity[keyof Entity];
      }
      return v as Entity[keyof Entity];
    } else {
      return value as Entity[keyof Entity];
    }
  }

  /**
   * Validates table name and schema configurations
   * Checks for:
   * 1. Valid table name format
   * 2. Valid schema key names
   * 3. No duplicate keys between primary key and value schemas
   * This is a sanity check to make sure the table and schema are valid,
   * and to prevent dumb mistakes and mischevious behavior.
   * @throws Error if validation fails
   */
  protected validateTableAndSchema(): void {
    // Validate table name
    if (!/^[a-zA-Z][a-zA-Z0-9_]*$/.test(this.table)) {
      throw new Error(
        "Table name must start with a letter and contain only letters, digits, and underscores, got: " +
          this.table
      );
    }

    // Validate schema keys
    const validateSchemaKeys = (schema: DataPortSchemaObject) => {
      for (const key in schema.properties) {
        if (!/^[a-zA-Z][a-zA-Z0-9_]*$/.test(key)) {
          throw new Error(
            "Schema keys must start with a letter and contain only letters, digits, and underscores, got: " +
              key
          );
        }
      }
    };

    validateSchemaKeys(this.primaryKeySchema);
    validateSchemaKeys(this.valueSchema);

    // Check for key name collisions between schemas
    const primaryKeys = new Set(Object.keys(this.primaryKeySchema.properties));
    const valueKeys = Object.keys(this.valueSchema.properties);
    const duplicates = valueKeys.filter((key) => primaryKeys.has(key));
    if (duplicates.length > 0) {
      throw new Error(`Duplicate keys found in schemas: ${duplicates.join(", ")}`);
    }
  }
}
