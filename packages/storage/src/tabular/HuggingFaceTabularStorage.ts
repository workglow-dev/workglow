/**
 * @license
 * Copyright 2025 Steven Roussey <sroussey@gmail.com>
 * SPDX-License-Identifier: Apache-2.0
 */

import {
  createServiceToken,
  DataPortSchemaObject,
  FromSchema,
  TypedArraySchemaOptions,
} from "@workglow/util";
import { BaseTabularStorage, ClientProvidedKeysOption } from "./BaseTabularStorage";
import {
  AnyTabularStorage,
  AutoGeneratedKeys,
  DeleteSearchCriteria,
  InsertEntity,
  SimplifyPrimaryKey,
  TabularChangePayload,
  TabularSubscribeOptions,
} from "./ITabularStorage";

export const HF_TABULAR_REPOSITORY = createServiceToken<AnyTabularStorage>(
  "storage.tabularRepository.huggingface"
);

/**
 * HuggingFace Dataset Viewer API response types
 */
interface HfFirstRowsResponse {
  features: Array<{ feature_idx: number; name: string; type: any }>;
  rows: Array<{ row_idx: number; row: Record<string, any>; truncated_cells: any[] }>;
}

interface HfRowsResponse {
  features: Array<{ feature_idx: number; name: string; type: any }>;
  rows: Array<{ row_idx: number; row: Record<string, any>; truncated_cells: any[] }>;
  num_rows_total: number;
  num_rows_per_page: number;
  partial: boolean;
}

interface HfFilterResponse {
  features: Array<{ feature_idx: number; name: string; type: any }>;
  rows: Array<{ row_idx: number; row: Record<string, any>; truncated_cells: any[] }>;
  num_rows_total: number;
  num_rows_per_page: number;
  partial: boolean;
}

interface HfSizeResponse {
  size: {
    dataset: string;
    config: string;
    split: string;
    num_bytes_original_files: number;
    num_bytes_parquet_files: number;
    num_bytes_memory: number;
    num_rows: number;
    num_columns: number;
  };
  partial: boolean;
}

/**
 * Options for HuggingFaceTabularStorage
 */
export interface HuggingFaceTabularStorageOptions {
  /** HuggingFace API token for private datasets */
  token?: string;
  /** Base URL for the HuggingFace Dataset Viewer API */
  baseUrl?: string;
  /** Indexes for optimizing search operations */
  indexes?: readonly (keyof any | readonly (keyof any)[])[];
}

/**
 * Read-only tabular storage backed by HuggingFace Dataset Viewer API.
 * Supports both user-provided schemas and auto-detection from HF features.
 *
 * @template Schema - The schema definition for the entity using JSON Schema
 * @template PrimaryKeyNames - Array of property names that form the primary key
 */
export class HuggingFaceTabularStorage<
  Schema extends DataPortSchemaObject,
  PrimaryKeyNames extends ReadonlyArray<keyof Schema["properties"]>,
  // computed types
  Entity = FromSchema<Schema, TypedArraySchemaOptions>,
  PrimaryKey = SimplifyPrimaryKey<Entity, PrimaryKeyNames>,
  Value = Omit<Entity, PrimaryKeyNames[number] & keyof Entity>,
  InsertType extends InsertEntity<Entity, AutoGeneratedKeys<Schema>> = InsertEntity<
    Entity,
    AutoGeneratedKeys<Schema>
  >,
> extends BaseTabularStorage<Schema, PrimaryKeyNames, Entity, PrimaryKey, Value, InsertType> {
  private readonly dataset: string;
  private readonly config: string;
  private readonly split: string;
  private readonly token?: string;
  private readonly baseUrl: string;

  /**
   * Creates a new HuggingFaceTabularStorage instance
   * @param dataset - HuggingFace dataset name (e.g., "cornell-movie-review-data/rotten_tomatoes")
   * @param config - Dataset configuration (e.g., "default")
   * @param split - Dataset split (e.g., "train", "test", "validation")
   * @param schema - Schema defining the structure of the entity
   * @param primaryKeyNames - Array of property names that form the primary key
   * @param options - Optional configuration including token, baseUrl, and indexes
   */
  constructor(
    dataset: string,
    config: string,
    split: string,
    schema: Schema,
    primaryKeyNames: PrimaryKeyNames,
    options?: HuggingFaceTabularStorageOptions
  ) {
    super(
      schema,
      primaryKeyNames,
      (options?.indexes ?? []) as readonly (keyof Entity | readonly (keyof Entity)[])[], 
      "never" // HF datasets don't support client-provided keys
    );
    this.dataset = dataset;
    this.config = config;
    this.split = split;
    this.token = options?.token;
    this.baseUrl = options?.baseUrl ?? "https://datasets-server.huggingface.co";
  }

  /**
   * Factory method to create a HuggingFaceTabularStorage instance with auto-detected schema.
   * Fetches the dataset features and converts them to a JSON Schema.
   *
   * @param dataset - HuggingFace dataset name
   * @param config - Dataset configuration
   * @param split - Dataset split
   * @param options - Optional configuration
   * @returns A new HuggingFaceTabularStorage instance with auto-detected schema
   */
  static async fromDataset<Entity = any>(
    dataset: string,
    config: string,
    split: string,
    options?: HuggingFaceTabularStorageOptions
  ): Promise<
    HuggingFaceTabularStorage<DataPortSchemaObject, readonly ["row_idx"], Entity, number, any, any>
  > {
    const baseUrl = options?.baseUrl ?? "https://datasets-server.huggingface.co";
    const token = options?.token;

    // Fetch first rows to get features
    const url = new URL(`${baseUrl}/first-rows`);
    url.searchParams.set("dataset", dataset);
    url.searchParams.set("config", config);
    url.searchParams.set("split", split);

    const headers: Record<string, string> = {};
    if (token) {
      headers["Authorization"] = `Bearer ${token}`;
    }

    const response = await fetch(url.toString(), { headers });
    if (!response.ok) {
      throw new Error(
        `Failed to fetch dataset features: ${response.status} ${response.statusText}`
      );
    }

    const data: HfFirstRowsResponse = await response.json();

    // Convert HF features to JSON Schema
    const properties: Record<string, any> = {};
    const required: string[] = [];

    // Add row_idx as primary key (auto-generated by HF)
    properties["row_idx"] = { type: "integer", "x-auto-generated": true };
    required.push("row_idx");

    for (const feature of data.features) {
      const jsonSchema = hfFeatureToJsonSchema(feature.type);
      properties[feature.name] = jsonSchema;
      // HF datasets typically don't have null values unless specified
      required.push(feature.name);
    }

    const schema: DataPortSchemaObject = {
      type: "object",
      properties,
      required,
      additionalProperties: false,
    };

    return new HuggingFaceTabularStorage(
      dataset,
      config,
      split,
      schema,
      ["row_idx"] as const,
      options
    ) as any;
  }

  /**
   * Sets up the database by validating the dataset exists and schema matches
   */
  async setupDatabase(): Promise<void> {
    // Fetch first rows to validate dataset exists
    const data = await this.fetchApi<HfFirstRowsResponse>("/first-rows", {});

    // Validate that schema columns match HF features (if schema was user-provided)
    const schemaColumns = Object.keys(this.schema.properties);
    const hfColumns = data.features.map((f) => f.name);

    // Check if row_idx is in schema (indicates auto-detected schema)
    const hasRowIdx = schemaColumns.includes("row_idx");

    if (!hasRowIdx) {
      // User-provided schema - validate columns match
      for (const column of schemaColumns) {
        if (!hfColumns.includes(column) && !this.primaryKeyNames.includes(column as any)) {
          throw new Error(`Schema column "${column}" not found in HuggingFace dataset features`);
        }
      }
    }
  }

  /**
   * Retrieves a value by its key using the /filter endpoint
   */
  async get(key: PrimaryKey): Promise<Entity | undefined> {
    const keyObj = this.separateKeyValueFromCombined({ ...key } as any).key;
    const whereConditions: string[] = [];

    for (const [k, v] of Object.entries(keyObj as Record<string, any>)) {
      if (typeof v === "string") {
        // Escape backslashes first, then single quotes
        const escaped = v.replace(/\\/g, "\\\\").replace(/'/g, "\\'");
        whereConditions.push(`${k}='${escaped}'`);
      } else {
        whereConditions.push(`${k}=${v}`);
      }
    }

    const where = whereConditions.join(" AND ");
    const data = await this.fetchApi<HfFilterResponse>("/filter", { where, limit: "1" });

    if (data.rows.length > 0) {
      const entity = this.rowToEntity(data.rows[0]);
      this.events.emit("get", key, entity);
      return entity;
    }

    this.events.emit("get", key, undefined);
    return undefined;
  }

  /**
   * Retrieves all entities by paginating through the /rows endpoint
   */
  async getAll(): Promise<Entity[] | undefined> {
    const allEntities: Entity[] = [];
    let offset = 0;
    const length = 100; // HF max per request

    while (true) {
      const data = await this.fetchApi<HfRowsResponse>("/rows", {
        offset: offset.toString(),
        length: length.toString(),
      });

      for (const row of data.rows) {
        allEntities.push(this.rowToEntity(row));
      }

      offset += data.rows.length;

      // Check if we've retrieved all rows
      if (offset >= data.num_rows_total || data.rows.length < length) {
        break;
      }
    }

    return allEntities.length > 0 ? allEntities : undefined;
  }

  /**
   * Searches for entities matching a partial key using the /filter endpoint
   */
  async search(key: Partial<Entity>): Promise<Entity[] | undefined> {
    const searchKeys = Object.keys(key) as Array<keyof Entity>;
    if (searchKeys.length === 0) {
      return undefined;
    }

    // Find the best matching index
    const bestIndex = this.findBestMatchingIndex(searchKeys);
    if (!bestIndex) {
      throw new Error(
        `No suitable index found for the search criteria, searching for ['${searchKeys.join(
          "', '"
        )}'] with pk ['${this.primaryKeyNames.join("', '")}'] and indexes ['${this.indexes
          .map((idx) => idx.join(","))
          .join("', '")}'`
      );
    }

    // Build WHERE clause
    const whereConditions: string[] = [];
    for (const [k, v] of Object.entries(key)) {
      if (v !== undefined && v !== null) {
        if (typeof v === "string") {
          // Escape backslashes first, then single quotes
          const escaped = v.replace(/\\/g, "\\\\").replace(/'/g, "\\'");
          whereConditions.push(`${k}='${escaped}'`);
        } else {
          whereConditions.push(`${k}=${v}`);
        }
      }
    }

    const where = whereConditions.join(" AND ");
    const allEntities: Entity[] = [];
    let offset = 0;
    const limit = 100;

    while (true) {
      const data = await this.fetchApi<HfFilterResponse>("/filter", {
        where,
        offset: offset.toString(),
        limit: limit.toString(),
      });

      for (const row of data.rows) {
        allEntities.push(this.rowToEntity(row));
      }

      offset += data.rows.length;

      // Check if we've retrieved all matching rows
      if (offset >= data.num_rows_total || data.rows.length < limit) {
        break;
      }
    }

    if (allEntities.length > 0) {
      this.events.emit("search", key, allEntities);
      return allEntities;
    } else {
      this.events.emit("search", key, undefined);
      return undefined;
    }
  }

  /**
   * Returns the number of rows in the dataset using the /size endpoint
   */
  async size(): Promise<number> {
    const data = await this.fetchApi<HfSizeResponse>("/size", {});
    return data.size.num_rows;
  }

  /**
   * Write operations are not supported - throws readonly error
   */
  async put(_value: InsertType): Promise<Entity> {
    throw new Error("HuggingFaceTabularStorage is readonly");
  }

  /**
   * Write operations are not supported - throws readonly error
   */
  async putBulk(_values: InsertType[]): Promise<Entity[]> {
    throw new Error("HuggingFaceTabularStorage is readonly");
  }

  /**
   * Delete operations are not supported - throws readonly error
   */
  async delete(_value: PrimaryKey | Entity): Promise<void> {
    throw new Error("HuggingFaceTabularStorage is readonly");
  }

  /**
   * Delete operations are not supported - throws readonly error
   */
  async deleteAll(): Promise<void> {
    throw new Error("HuggingFaceTabularStorage is readonly");
  }

  /**
   * Delete operations are not supported - throws readonly error
   */
  async deleteSearch(_criteria: DeleteSearchCriteria<Entity>): Promise<void> {
    throw new Error("HuggingFaceTabularStorage is readonly");
  }

  /**
   * Subscriptions are not supported - HF datasets are static
   */
  subscribeToChanges(
    _callback: (change: TabularChangePayload<Entity>) => void,
    _options?: TabularSubscribeOptions
  ): () => void {
    throw new Error("HuggingFaceTabularStorage does not support subscriptions");
  }

  /**
   * No resources to clean up
   */
  destroy(): void {
    // No-op - no resources to clean up
  }

  /**
   * Helper method to fetch from the HuggingFace Dataset Viewer API
   */
  private async fetchApi<T>(
    endpoint: string,
    params: Record<string, string>
  ): Promise<T> {
    const url = new URL(`${this.baseUrl}${endpoint}`);
    url.searchParams.set("dataset", this.dataset);
    url.searchParams.set("config", this.config);
    url.searchParams.set("split", this.split);

    for (const [key, value] of Object.entries(params)) {
      if (value !== undefined) {
        url.searchParams.set(key, value);
      }
    }

    const headers: Record<string, string> = {};
    if (this.token) {
      headers["Authorization"] = `Bearer ${this.token}`;
    }

    const response = await fetch(url.toString(), { headers });
    if (!response.ok) {
      throw new Error(
        `HuggingFace API error: ${response.status} ${response.statusText}`
      );
    }

    return await response.json();
  }

  /**
   * Converts a HF row to an Entity
   */
  private rowToEntity(row: { row_idx: number; row: Record<string, any> }): Entity {
    return { row_idx: row.row_idx, ...row.row } as Entity;
  }
}

/**
 * Converts a HuggingFace feature type to a JSON Schema type definition
 */
function hfFeatureToJsonSchema(feature: any): any {
  // Handle Value types
  if (feature._type === "Value") {
    switch (feature.dtype) {
      case "string":
        return { type: "string" };
      case "int64":
      case "int32":
      case "int16":
      case "int8":
      case "uint64":
      case "uint32":
      case "uint16":
      case "uint8":
        return { type: "integer" };
      case "float64":
      case "float32":
      case "float16":
        return { type: "number" };
      case "bool":
        return { type: "boolean" };
      default:
        return {}; // any type
    }
  }

  // Handle ClassLabel types
  if (feature._type === "ClassLabel") {
    return { type: "integer" };
  }

  // Handle Sequence types
  if (feature._type === "Sequence") {
    return {
      type: "array",
      items: hfFeatureToJsonSchema(feature.feature),
    };
  }

  // Handle other types as any
  return {};
}
