/**
 * @license
 * Copyright 2025 Steven Roussey <sroussey@gmail.com>
 * SPDX-License-Identifier: Apache-2.0
 */

import type { RealtimeChannel, SupabaseClient } from "@supabase/supabase-js";
import {
  createServiceToken,
  DataPortSchemaObject,
  FromSchema,
  JsonSchema,
  TypedArraySchemaOptions,
} from "@workglow/util";
import { BaseSqlTabularStorage } from "./BaseSqlTabularStorage";
import { ClientProvidedKeysOption } from "./BaseTabularStorage";
import {
  AnyTabularStorage,
  AutoGeneratedKeys,
  DeleteSearchCriteria,
  InsertEntity,
  isSearchCondition,
  SearchOperator,
  SimplifyPrimaryKey,
  TabularChangePayload,
  TabularChangeType,
  TabularSubscribeOptions,
  ValueOptionType,
} from "./ITabularStorage";

export const SUPABASE_TABULAR_REPOSITORY = createServiceToken<AnyTabularStorage>(
  "storage.tabularRepository.supabase"
);

/**
 * A Supabase-based tabular repository implementation that extends BaseSqlTabularStorage.
 * This class provides persistent storage for data in a Supabase database,
 * making it suitable for multi-user scenarios.
 *
 * @template Schema - The schema definition for the entity
 * @template PrimaryKeyNames - Array of property names that form the primary key
 */
export class SupabaseTabularStorage<
  Schema extends DataPortSchemaObject,
  PrimaryKeyNames extends ReadonlyArray<keyof Schema["properties"]>,
  // computed types
  Entity = FromSchema<Schema, TypedArraySchemaOptions>,
  PrimaryKey = SimplifyPrimaryKey<Entity, PrimaryKeyNames>,
  Value = Omit<Entity, PrimaryKeyNames[number] & keyof Entity>,
  InsertType extends InsertEntity<Entity, AutoGeneratedKeys<Schema>> = InsertEntity<
    Entity,
    AutoGeneratedKeys<Schema>
  >,
> extends BaseSqlTabularStorage<Schema, PrimaryKeyNames, Entity, PrimaryKey, Value, InsertType> {
  private client: SupabaseClient;
  private realtimeChannel: RealtimeChannel | null = null;

  /**
   * Creates a new SupabaseTabularStorage instance.
   *
   * @param client - Supabase client instance
   * @param table - Name of the table to store data (defaults to "tabular_store")
   * @param schema - Schema defining the structure of the entity
   * @param primaryKeyNames - Array of property names that form the primary key
   * @param indexes - Array of columns or column arrays to make searchable. Each string or single column creates a single-column index,
   *                    while each array creates a compound index with columns in the specified order.
   * @param clientProvidedKeys - How to handle client-provided values for auto-generated keys
   */
  constructor(
    client: SupabaseClient,
    table: string = "tabular_store",
    schema: Schema,
    primaryKeyNames: PrimaryKeyNames,
    indexes: readonly (keyof Entity | readonly (keyof Entity)[])[] = [],
    clientProvidedKeys: ClientProvidedKeysOption = "if-missing"
  ) {
    super(table, schema, primaryKeyNames, indexes, clientProvidedKeys);
    this.client = client;
  }

  /**
   * Initializes the database table with the required schema.
   * Creates the table if it doesn't exist with primary key and value columns.
   * Must be called before using any other methods.
   */
  public async setupDatabase(): Promise<void> {
    const sql = `
      CREATE TABLE IF NOT EXISTS "${this.table}" (
        ${this.constructPrimaryKeyColumns('"')} ${this.constructValueColumns('"')},
        PRIMARY KEY (${this.primaryKeyColumnList()}) 
      )
    `;
    const { error } = await this.client.rpc("exec_sql", { query: sql });
    if (error && !error.message.includes("already exists")) {
      throw error;
    }

    // Get primary key columns to avoid creating redundant indexes
    const pkColumns = this.primaryKeyColumns();

    // Track created indexes to avoid duplicates and redundant indexes
    const createdIndexes = new Set<string>();

    for (const columns of this.indexes) {
      // Skip if this is just the primary key or a prefix of it
      if (columns.length <= pkColumns.length) {
        // @ts-ignore
        const isPkPrefix = columns.every((col, idx) => col === pkColumns[idx]);
        if (isPkPrefix) continue;
      }

      // Create index name and column list
      const indexName = `${this.table}_${columns.join("_")}`;
      const columnList = columns.map((col) => `"${String(col)}"`).join(", ");

      // Skip if we've already created this index or if it's redundant
      const columnKey = columns.join(",");
      if (createdIndexes.has(columnKey)) continue;

      // Check if this index would be redundant with an existing one
      const isRedundant = Array.from(createdIndexes).some((existing) => {
        const existingCols = existing.split(",");
        return (
          existingCols.length >= columns.length &&
          columns.every((col, idx) => col === existingCols[idx])
        );
      });

      if (!isRedundant) {
        const indexSql = `CREATE INDEX IF NOT EXISTS "${indexName}" ON "${this.table}" (${columnList})`;
        const { error: indexError } = await this.client.rpc("exec_sql", { query: indexSql });
        if (indexError && !indexError.message.includes("already exists")) {
          // Index creation errors are not critical, log and continue
          console.warn(`Failed to create index ${indexName}:`, indexError);
        }
        createdIndexes.add(columnKey);
      }
    }
  }

  /**
   * Maps TypeScript/JavaScript types to corresponding PostgreSQL data types.
   * Uses additional schema information like minimum/maximum values, nullable status,
   * and string lengths to create more optimized column types.
   *
   * @param typeDef - The TypeScript/JavaScript type to map
   * @returns The corresponding PostgreSQL data type
   */
  protected mapTypeToSQL(typeDef: JsonSchema): string {
    // Extract the actual non-null type using base helper
    const actualType = this.getNonNullType(typeDef);
    if (typeof actualType === "boolean") {
      return "TEXT /* boolean schema */";
    }

    // Handle BLOB type
    if (actualType.contentEncoding === "blob") return "BYTEA";

    switch (actualType.type) {
      case "string":
        // Handle special string formats
        if (actualType.format === "date-time") return "TIMESTAMP";
        if (actualType.format === "date") return "DATE";
        if (actualType.format === "email") return "VARCHAR(255)";
        if (actualType.format === "uri") return "VARCHAR(2048)";
        if (actualType.format === "uuid") return "UUID";

        // Use a VARCHAR with maxLength if specified
        if (typeof actualType.maxLength === "number") {
          return `VARCHAR(${actualType.maxLength})`;
        }

        // Default to TEXT for strings without constraints
        return "TEXT";

      case "number":
      case "integer":
        // Handle integer vs floating point
        if (actualType.multipleOf === 1 || actualType.type === "integer") {
          // Use PostgreSQL's numeric range types based on min/max values
          if (typeof actualType.minimum === "number") {
            if (actualType.minimum >= 0) {
              // For unsigned integers
              if (typeof actualType.maximum === "number") {
                if (actualType.maximum <= 32767) return "SMALLINT";
                if (actualType.maximum <= 2147483647) return "INTEGER";
              }
              return "BIGINT";
            }
          }

          // Default integer type
          return "INTEGER";
        }

        // For floating point numbers with precision requirements
        if (actualType.format === "float") return "REAL";
        if (actualType.format === "double") return "DOUBLE PRECISION";

        // Use NUMERIC with precision/scale if specified
        if (typeof actualType.multipleOf === "number") {
          const decimalPlaces = String(actualType.multipleOf).split(".")[1]?.length || 0;
          if (decimalPlaces > 0) {
            return `NUMERIC(38, ${decimalPlaces})`;
          }
        }

        return "NUMERIC";

      case "boolean":
        return "BOOLEAN";

      case "array":
        // Handle array types (if items type is specified)
        if (
          actualType.items &&
          typeof actualType.items === "object" &&
          !Array.isArray(actualType.items)
        ) {
          const itemType = this.mapTypeToSQL(actualType.items as JsonSchema);

          // Only use native PostgreSQL arrays for simple scalar types
          // List of types that work well as native PostgreSQL arrays
          const supportedArrayElementTypes = [
            "TEXT",
            "VARCHAR",
            "CHAR",
            "INTEGER",
            "SMALLINT",
            "BIGINT",
            "REAL",
            "DOUBLE PRECISION",
            "NUMERIC",
            "BOOLEAN",
            "UUID",
            "DATE",
            "TIMESTAMP",
          ];

          // Check if the item type is in our supported list (either exact match or starts with for VARCHAR types)
          const isSupported = supportedArrayElementTypes.some(
            (type) => itemType === type || (itemType.startsWith(type + "(") && type !== "VARCHAR") // Handle things like VARCHAR(255)
          );

          if (isSupported) {
            return `${itemType}[]`;
          } else {
            return "JSONB /* complex array */";
          }
        }
        return "JSONB /* generic array */";

      case "object":
        return "JSONB /* object */";

      default:
        return "TEXT /* unknown type */";
    }
  }

  /**
   * Generates the SQL column definitions for primary key fields with constraints
   * Handles auto-generated keys using SERIAL for integers and UUID DEFAULT for strings
   * @returns SQL string containing primary key column definitions
   */
  protected constructPrimaryKeyColumns($delimiter: string = ""): string {
    const cols = Object.entries<JsonSchema>(this.primaryKeySchema.properties)
      .map(([key, typeDef]) => {
        // Check if this is an auto-generated key
        if (this.isAutoGeneratedKey(key)) {
          if (this.autoGeneratedKeyStrategy === "autoincrement") {
            // Use SERIAL or BIGSERIAL for auto-increment
            const sqlType = this.mapTypeToSQL(typeDef);
            const isSmallInt = sqlType.includes("SMALLINT");
            const isBigInt = sqlType.includes("BIGINT");
            const serialType = isBigInt ? "BIGSERIAL" : isSmallInt ? "SMALLSERIAL" : "SERIAL";
            return `${$delimiter}${key}${$delimiter} ${serialType}`;
          } else if (this.autoGeneratedKeyStrategy === "uuid") {
            // Use UUID with DEFAULT gen_random_uuid()
            return `${$delimiter}${key}${$delimiter} UUID DEFAULT gen_random_uuid()`;
          }
        }

        const sqlType = this.mapTypeToSQL(typeDef);
        let constraints = "NOT NULL";

        // Add CHECK constraint for unsigned numbers
        if (this.shouldBeUnsigned(typeDef)) {
          constraints += ` CHECK (${$delimiter}${key}${$delimiter} >= 0)`;
        }

        return `${$delimiter}${key}${$delimiter} ${sqlType} ${constraints}`;
      })
      .join(", ");
    return cols;
  }

  /**
   * Generates the SQL column definitions for value fields with constraints
   * @returns SQL string containing value column definitions
   */
  protected constructValueColumns($delimiter: string = ""): string {
    const delimiter = $delimiter || '"';
    const requiredSet = new Set(this.valueSchema.required ?? []);
    const cols = Object.entries<JsonSchema>(this.valueSchema.properties)
      .map(([key, typeDef]) => {
        const sqlType = this.mapTypeToSQL(typeDef);
        const isRequired = requiredSet.has(key);
        const nullable = !isRequired || this.isNullable(typeDef);
        let constraints = nullable ? "NULL" : "NOT NULL";

        // Add CHECK constraint for unsigned numbers
        if (this.shouldBeUnsigned(typeDef)) {
          constraints += ` CHECK (${delimiter}${key}${delimiter} >= 0)`;
        }

        return `${delimiter}${key}${delimiter} ${sqlType} ${constraints}`;
      })
      .join(", ");
    if (cols.length > 0) {
      return `, ${cols}`;
    } else {
      return "";
    }
  }

  /**
   * Convert Supabase values to JS values. Ensures numeric strings become numbers where schema says number.
   */
  protected sqlToJsValue(column: string, value: ValueOptionType): Entity[keyof Entity] {
    const typeDef = this.schema.properties[column as keyof typeof this.schema.properties] as
      | JsonSchema
      | undefined;
    if (typeDef) {
      if (value === null && this.isNullable(typeDef)) {
        return null as any;
      }
      const actualType = this.getNonNullType(typeDef);

      // Handle numeric types - Supabase can return them as strings
      if (
        typeof actualType !== "boolean" &&
        (actualType.type === "number" || actualType.type === "integer")
      ) {
        const v: any = value;
        if (typeof v === "number") return v as any;
        if (typeof v === "string") {
          const parsed = Number(v);
          if (!isNaN(parsed)) return parsed as any;
        }
      }
    }
    return super.sqlToJsValue(column, value);
  }

  /**
   * Determines if a field should be treated as unsigned based on schema properties
   * @param typeDef - The schema type definition
   * @returns true if the field should be treated as unsigned
   */
  protected shouldBeUnsigned(typeDef: JsonSchema): boolean {
    // Extract the non-null type using the base class helper
    const actualType = this.getNonNullType(typeDef);
    if (typeof actualType === "boolean") {
      return false;
    }

    // Check if it's a number type with minimum >= 0
    if (
      (actualType.type === "number" || actualType.type === "integer") &&
      typeof actualType.minimum === "number" &&
      actualType.minimum >= 0
    ) {
      return true;
    }

    return false;
  }

  /**
   * Stores or updates a row in the database.
   * Uses UPSERT (INSERT ... ON CONFLICT DO UPDATE) for atomic operations.
   *
   * @param entity - The entity to store (may be missing auto-generated keys)
   * @returns The entity with any server-generated fields updated
   * @emits "put" event with the updated entity when successful
   */
  async put(entity: InsertType): Promise<Entity> {
    // Handle auto-generated keys
    let entityToInsert = { ...entity };
    
    if (this.hasAutoGeneratedKey() && this.autoGeneratedKeyName) {
      const keyName = String(this.autoGeneratedKeyName);
      const clientProvidedValue = (entity as any)[keyName];
      const hasClientValue = clientProvidedValue !== undefined && clientProvidedValue !== null;

      let shouldOmitKey = false;
      if (this.clientProvidedKeys === "never") {
        // Never use client value, let database generate
        shouldOmitKey = true;
      } else if (this.clientProvidedKeys === "always") {
        if (!hasClientValue) {
          throw new Error(
            `Auto-generated key "${keyName}" is required when clientProvidedKeys is "always"`
          );
        }
        shouldOmitKey = false;
      } else {
        // "if-missing" - omit key if client didn't provide it
        shouldOmitKey = !hasClientValue;
      }

      if (shouldOmitKey) {
        // Omit the auto-generated key so Supabase generates it
        delete (entityToInsert as any)[keyName];
      }
    }

    // Normalize optional fields: convert undefined to null for optional fields
    const normalizedEntity = { ...entityToInsert } as any;
    const requiredSet = new Set(this.valueSchema.required ?? []);
    for (const key in this.valueSchema.properties) {
      if (!(key in normalizedEntity) || normalizedEntity[key] === undefined) {
        if (!requiredSet.has(key)) {
          normalizedEntity[key] = null;
        }
      }
    }
    const { data, error} = await this.client
      .from(this.table)
      .upsert(normalizedEntity, { onConflict: this.primaryKeyColumnList() })
      .select()
      .single();

    if (error) throw error;
    const updatedEntity = data as Entity;

    // Convert all columns from SQL to JS values
    for (const key in this.schema.properties) {
      // @ts-ignore
      updatedEntity[key] = this.sqlToJsValue(key, updatedEntity[key]);
    }

    this.events.emit("put", updatedEntity);
    return updatedEntity;
  }

  /**
   * Stores multiple rows in the database in a bulk operation.
   * Uses individual put calls to ensure auto-generated keys are handled correctly.
   *
   * @param entities - Array of entities to store (may be missing auto-generated keys)
   * @returns Array of entities with any server-generated fields updated
   * @emits "put" event for each entity stored
   */
  async putBulk(entities: InsertType[]): Promise<Entity[]> {
    if (entities.length === 0) return [];

    // Use individual put calls to ensure auto-generated keys are handled correctly
    return await Promise.all(entities.map((entity) => this.put(entity)));
  }

  /**
   * Retrieves a value from the database by its primary key.
   *
   * @param key - The primary key object to look up
   * @returns The stored entity or undefined if not found
   * @emits "get" event with the key when successful
   */
  async get(key: PrimaryKey): Promise<Entity | undefined> {
    let query = this.client.from(this.table).select("*");

    // Build the where clause from primary key
    for (const pkName of this.primaryKeyNames) {
      query = query.eq(String(pkName), (key as any)[pkName]);
    }

    const { data, error } = await query.single();

    if (error) {
      if (error.code === "PGRST116") {
        // Not found
        this.events.emit("get", key, undefined);
        return undefined;
      }
      throw error;
    }

    const val = data as Entity | undefined;
    if (val) {
      // Convert all columns from SQL to JS values
      for (const key in this.schema.properties) {
        // @ts-ignore
        val[key] = this.sqlToJsValue(key, val[key]);
      }
    }
    this.events.emit("get", key, val);
    return val;
  }

  /**
   * Method to search for rows based on a partial key.
   *
   * @param searchCriteria - Partial entity to search for
   * @returns Promise resolving to an array of entities or undefined if not found
   */
  public async search(searchCriteria: Partial<Entity>): Promise<Entity[] | undefined> {
    const searchKeys = Object.keys(searchCriteria);
    if (searchKeys.length === 0) {
      return undefined;
    }

    // Find the best matching index for the search
    const bestIndex = this.findBestMatchingIndex(searchKeys as Array<keyof Entity>);
    if (!bestIndex) {
      throw new Error(
        `No suitable index found for the search criteria, searching for ['${searchKeys.join(
          "', '"
        )}'] with pk ['${this.primaryKeyNames.join("', '")}'] and indexes ['${this.indexes.join(
          "', '"
        )}']`
      );
    }

    // Verify columns in primary key or value schema
    const validColumns = [...this.primaryKeyColumns(), ...this.valueColumns()];
    // @ts-expect-error
    const invalidColumns = searchKeys.filter((key) => !validColumns.includes(key));
    if (invalidColumns.length > 0) {
      throw new Error(`Invalid columns in search criteria: ${invalidColumns.join(", ")}`);
    }

    let query = this.client.from(this.table).select("*");

    // Build the where clause from search criteria
    for (const [key, value] of Object.entries(searchCriteria)) {
      query = query.eq(key, value);
    }

    const { data, error } = await query;

    if (error) throw error;

    if (data && data.length > 0) {
      // Convert all columns from SQL to JS values
      for (const row of data) {
        for (const key in this.schema.properties) {
          // @ts-ignore
          row[key] = this.sqlToJsValue(key, row[key]);
        }
      }
      this.events.emit("search", searchCriteria, data as Entity[]);
      return data as Entity[];
    } else {
      this.events.emit("search", searchCriteria, undefined);
      return undefined;
    }
  }

  /**
   * Deletes a row from the database.
   *
   * @param value - The primary key object or entity to delete
   * @emits "delete" event with the key when successful
   */
  async delete(value: PrimaryKey | Entity): Promise<void> {
    const { key } = this.separateKeyValueFromCombined(value as Entity);

    let query = this.client.from(this.table).delete();

    // Build the where clause from primary key
    for (const pkName of this.primaryKeyNames) {
      query = query.eq(String(pkName), (key as any)[pkName]);
    }

    const { error } = await query;

    if (error) throw error;
    this.events.emit("delete", key as keyof Entity);
  }

  /**
   * Retrieves all entries from the database table
   * @returns Promise resolving to an array of entries or undefined if not found
   */
  async getAll(): Promise<Entity[] | undefined> {
    const { data, error } = await this.client.from(this.table).select("*");

    if (error) throw error;

    if (data && data.length) {
      // Convert all columns from SQL to JS values
      for (const row of data) {
        for (const key in this.schema.properties) {
          // @ts-ignore
          row[key] = this.sqlToJsValue(key, row[key]);
        }
      }
      return data as Entity[];
    }
    return undefined;
  }

  /**
   * Deletes all rows from the database table.
   * @emits "clearall" event when successful
   */
  async deleteAll(): Promise<void> {
    // Use the first primary key column for the delete condition
    const firstPkColumn = this.primaryKeyNames[0];
    const { error } = await this.client.from(this.table).delete().neq(String(firstPkColumn), null); // Delete all rows by using a condition that's always true

    if (error) throw error;
    this.events.emit("clearall");
  }

  /**
   * Returns the total number of rows in the database.
   *
   * @returns Promise resolving to the count of stored items
   */
  async size(): Promise<number> {
    const { count, error } = await this.client
      .from(this.table)
      .select("*", { count: "exact", head: true });

    if (error) throw error;
    return count ?? 0;
  }

  /**
   * Fetches a page of records from the repository.
   * @param offset - Number of records to skip
   * @param limit - Maximum number of records to return
   * @returns Array of entities or undefined if no records found
   */
  async getBulk(offset: number, limit: number): Promise<Entity[] | undefined> {
    // Build the base query
    let query = this.client.from(this.table).select("*");

    // Ensure deterministic ordering for pagination by ordering on primary key column(s)
    for (const pkName of this.primaryKeyNames) {
      if (pkName != null) {
        query = query.order(String(pkName));
      }
    }

    const { data, error } = await query.range(offset, offset + limit - 1);

    if (error) throw error;
    
    if (!data || data.length === 0) {
      return undefined;
    }

    // Convert all columns from SQL to JS values (consistent with getAll)
    for (const row of data) {
      for (const key in this.schema.properties) {
        (row as any)[key] = this.sqlToJsValue(key, (row as any)[key]);
      }
    }

    return data as Entity[];
  }

  /**
   * Deletes all entries matching the specified search criteria.
   * Supports multiple columns with optional comparison operators.
   *
   * @param criteria - Object with column names as keys and values or SearchConditions
   */
  async deleteSearch(criteria: DeleteSearchCriteria<Entity>): Promise<void> {
    const criteriaKeys = Object.keys(criteria) as Array<keyof Entity>;
    if (criteriaKeys.length === 0) {
      return;
    }

    let query = this.client.from(this.table).delete();

    for (const column of criteriaKeys) {
      if (!(column in this.schema.properties)) {
        throw new Error(`Schema must have a ${String(column)} field to use deleteSearch`);
      }

      const criterion = criteria[column];
      let operator: SearchOperator = "=";
      let value: Entity[keyof Entity];

      if (isSearchCondition(criterion)) {
        operator = criterion.operator;
        value = criterion.value as Entity[keyof Entity];
      } else {
        value = criterion as Entity[keyof Entity];
      }

      switch (operator) {
        case "=":
          query = query.eq(String(column), value);
          break;
        case "<":
          query = query.lt(String(column), value);
          break;
        case "<=":
          query = query.lte(String(column), value);
          break;
        case ">":
          query = query.gt(String(column), value);
          break;
        case ">=":
          query = query.gte(String(column), value);
          break;
      }
    }

    const { error } = await query;

    if (error) throw error;
    this.events.emit("delete", criteriaKeys[0] as keyof Entity);
  }

  /**
   * Converts a row from Supabase realtime payload to an Entity with proper type conversions.
   *
   * @param row - The raw row data from Supabase realtime
   * @returns The converted entity
   */
  private convertRealtimeRow(row: Record<string, unknown>): Entity {
    const entity = { ...row } as Entity;
    for (const key in this.schema.properties) {
      // @ts-ignore
      entity[key] = this.sqlToJsValue(key, row[key] as ValueOptionType);
    }
    return entity;
  }

  /**
   * Subscribes to changes in the repository using Supabase realtime.
   * Receives notifications for INSERT, UPDATE, and DELETE operations from any source.
   *
   * @param callback - Function called when a change occurs
   * @param options - Optional subscription options (not used for Supabase realtime)
   * @returns Unsubscribe function
   */
  subscribeToChanges(
    callback: (change: TabularChangePayload<Entity>) => void,
    options?: TabularSubscribeOptions
  ): () => void {
    // Create a unique channel name
    const channelName = `tabular-${this.table}-${Date.now()}`;

    this.realtimeChannel = this.client
      .channel(channelName)
      .on(
        "postgres_changes",
        {
          event: "*",
          schema: "public",
          table: this.table,
        },
        (payload) => {
          const change: TabularChangePayload<Entity> = {
            type: payload.eventType.toUpperCase() as TabularChangeType,
            old:
              payload.old && Object.keys(payload.old).length > 0
                ? this.convertRealtimeRow(payload.old)
                : undefined,
            new:
              payload.new && Object.keys(payload.new).length > 0
                ? this.convertRealtimeRow(payload.new)
                : undefined,
          };
          callback(change);
        }
      )
      .subscribe();

    return () => {
      if (this.realtimeChannel) {
        this.client.removeChannel(this.realtimeChannel);
        this.realtimeChannel = null;
      }
    };
  }

  /**
   * Destroys the repository and frees up resources.
   */
  destroy(): void {
    if (this.realtimeChannel) {
      this.client.removeChannel(this.realtimeChannel);
      this.realtimeChannel = null;
    }
  }
}
